//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using OranDataStructures;

namespace OranDataStructures
{
	public class AStarPriorityQueue<T>{

		protected List<AStarPriorityNode<T>> heap;
		public int Size{
			get{ return _size;	}
			private set{ _size = value;}
		}
		protected int _size;
		
		public delegate bool PriorityComparator(float firstPriority, float secondPriority);
		
		private PriorityComparator comparator;


		public AStarPriorityQueue (PriorityComparator comparator) {
			heap = new List<AStarPriorityNode<T>>();
			heap.Capacity=36;
			Size = 0;
			this.comparator = comparator;
		}

		public void Add (T item, T parent, float priority){
			_size++;
			AStarPriorityNode<T> newNode = new AStarPriorityNode<T>(item, parent, Size-1, priority);
			heap.Add(newNode);
			newNode.Index = heap.IndexOf(newNode);
			if(Size>=2){
				Upheap();
			}
		}

		public void Add(AStarPriorityNode<T> node){
			_size++;
			heap.Add(node);
			node.Index = heap.IndexOf(node);
			if(Size>=2){
				Upheap();
			}
		}

		public AStarPriorityNode<T> GetNode(int index){
			return heap[index];
		}

		public AStarPriorityNode<T> SearchNode(T item){
			AStarPriorityNode<T> searchResult = null;
			foreach(AStarPriorityNode<T> node in heap){
				if(node.Item.Equals(item)){
					searchResult = node;
					break;
				}
			}
			return searchResult;
		}

		public T Get(int index){
			return heap[index].Item;
		}
		
		public float PeekPriority(){
			return heap[0].Priority;
		}
		
		public T Pop(){
			AStarPriorityNode<T> highestPriorityElement = heap[0];
			if(Size>=2){
				heap[0] = heap[Size-1];
				heap[0].Index = 0;
				heap.RemoveAt(Size-1);
			} else {
				heap.RemoveAt(0);
			}
			Size--;
			if(Size>=2){
				DownHeap ();
			}
			return highestPriorityElement.Item;
		}

		public AStarPriorityNode<T> PopNode(){
			AStarPriorityNode<T> highestPriorityElement = heap[0];
			if(Size>=2){
				heap[0] = heap[Size-1];
				heap[0].Index = 0;
				heap.RemoveAt(Size-1);
			} else {
				heap.RemoveAt(0);
			}
			Size--;
			if(Size>=2){
				DownHeap ();
			}
			return highestPriorityElement;
		}
		
		public void Remove(T item){
			
		}
		
		public virtual bool Contains(T item){
			bool isInHeap=false;
			foreach(AStarPriorityNode<T> node in heap){
				if(node.Item.Equals(item)){
					isInHeap=true;
					break;
				}
			}
			return isInHeap;
		}
		
		protected void DownHeap(){
			int i=0;
			while (i<=(Size-1)/2){
				AStarPriorityNode<T> node = heap[i];
				
				AStarPriorityNode<T> biggerChild = GetBiggerChild(GetChildren(i));
				if(biggerChild==null){
					break;
				}
				
				if(comparator(biggerChild.Priority, node.Priority)){
					Swap(biggerChild.Index, node.Index);
					i = node.Index;
				} else {
					break;
				}
			}
		}
		
		protected void Upheap(){
			int i=Size-1;
			
			while(i>=0){
				AStarPriorityNode<T> node = heap[i];
				AStarPriorityNode<T> father = GetFather(node.Index);
				
				
				if(comparator(node.Priority, father.Priority)){
					Swap(node.Index, father.Index);
					i = node.Index;
					
				} else {
					break;
				}
			}
		}
		
		
		protected void BottomUp(){
			for(int i=Size/2 -1; i>=0; i++){
				AStarPriorityNode<T> father = heap[i];
				
				List<AStarPriorityNode<T>> children = GetChildren(i);
				AStarPriorityNode<T> biggerChild = GetBiggerChild(children);
				
				
				if(comparator( biggerChild.Priority, father.Priority )){
					Swap(biggerChild.Index, father.Index);
				}
			}
		}
		
		protected void Swap(int firstElementIntex, int secondElementIndex){
			if(firstElementIntex<0 || firstElementIntex>=Size){
	//			Debug.Log("firstElementIntex: "+firstElementIntex+" out of range. Size is: "+Size);
			}
			if(secondElementIndex<0 || secondElementIndex>=Size){
	//			Debug.Log("secondElementIndex: "+secondElementIndex+" out of range");
			}
			
			AStarPriorityNode<T> firstElement = heap[firstElementIntex];
			AStarPriorityNode<T> secondElement = heap[secondElementIndex];
			
			heap[firstElementIntex] = secondElement;
			heap[secondElementIndex] = firstElement;
			
			firstElement.Index = secondElementIndex;
			secondElement.Index = firstElementIntex;
		}
		
		protected List<AStarPriorityNode<T>> GetChildren(int fatherIndex){
			List<AStarPriorityNode<T>> children = new List<AStarPriorityNode<T>>();
			if(fatherIndex*2 +1<=Size-1){
				children.Add(heap[fatherIndex*2 +1]);
			}
			if(fatherIndex*2 +2<=Size-1){
				children.Add(heap[fatherIndex*2 +2]);
			}
			
			return children;
		}
		
		protected AStarPriorityNode<T> GetBiggerChild(List<AStarPriorityNode<T>> children){
			AStarPriorityNode<T> biggerChild = null;
			if(children.Count==1){
				biggerChild = children[0];
			}
			if(children.Count==2){
				biggerChild = ( comparator(children[0].Priority, children[1].Priority) )? children[0] : children[1];
			}
			return biggerChild;
		}
		
		protected AStarPriorityNode<T> GetFather(int i){
			return heap[(i-1)/2];
		}
		
		
		public void Clear(){
			heap = new List<AStarPriorityNode<T>>();
		}
		
		public override string ToString (){
			String heapString = "";
			for(int i=0; i<Size; i++){
				heapString += heap[i].Item+" ";
			}
			return heapString;
		}
		
		public void Reverse(){
			for(int i=0; i<Size; i++){
				if(i>=Size-1-i){
					break;
				}
				AStarPriorityNode<T> temp = heap[i];
				heap[i] = heap[Size-1-i];
				heap[Size-1-i] = temp;
			}
		}
		
		public List<T> ConvertToList(){
			List<T> list = new List<T>();
			
			for(int i=0; i<Size; i++){
				list[i] = Get(i);
			}
			return list;
		}
	}
}

